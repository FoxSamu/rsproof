use std::collections::BTreeMap;

use crate::expr::Name;

/// An entry in a [NameTable].
#[derive(PartialEq, Eq, PartialOrd, Ord, Debug, Clone)]
pub enum NameEntry {
    /// An name not bound to any scope. It globally represents the same name. Predicates, functions
    /// and uninterpreted constants all get an unbound name.
    Unbound(String),

    /// A name bound to some scope. These names come from quantifiers which bind a name to a certain scope.
    /// For example, in `(all x: P(x)) & (exists x: Q(x))`, the `x` in `P(x)` binds to the `all` scope while
    /// the `x` in `Q(x)` binds to the `exists` scope. The parser works around this by giving each scope a
    /// unique numerical ID and tagging each occurence of a bound name with the identifier of the scope it
    /// is bound to. Thus, `(all x: P(x)) & (exists x: Q(x))` will be translated to
    /// `(all x$0: P(x$0)) & (exists x$1: Q(x$1))`.
    Bound(String, usize),

    /// A name generated after parsing, for example by a Tseitin transformation. Such names were not given
    /// explicit identifiers in the source code and thus only have a numeric identity.
    Synthetic
}

impl NameEntry {
    /// If the name entry has an identifier, return this identifier. Returns [None] otherwise.
    pub fn identifier(&self) -> Option<&String> {
        match self {
            NameEntry::Unbound(id) => Some(id),
            NameEntry::Bound(id, _) => Some(id),
            NameEntry::Synthetic => None,
        }
    }

    /// If the name entry is tied to a scope, return the scope ID. Returns [None] otherwise.
    pub fn scope(&self) -> Option<usize> {
        match self {
            NameEntry::Unbound(_) => None,
            NameEntry::Bound(_, scope) => Some(*scope),
            NameEntry::Synthetic => None,
        }
    }


    pub fn write(&self, name: &Name) -> String {
        match self {
            NameEntry::Unbound(name) => name.clone(),
            NameEntry::Bound(name, scope) => format!("{name}${scope}"),
            NameEntry::Synthetic => format!("${name}"),
        }
    }
}


/// A name table is a table generated by the parser that allows one to reverse-engineer numeric names back to
/// the human-readable names in the source code.
#[derive(Debug, Clone)]
pub struct NameTable {
    table: BTreeMap<Name, NameEntry>
}

impl NameTable {
    /// Creates a new, empty name table.
    pub fn new() -> Self {
        Self {
            table: BTreeMap::new()
        }
    }

    /// Add a new entry to the name table.
    pub fn add(&mut self, name: Name, entry: NameEntry) {
        self.table.insert(name, entry);
    }

    /// Add an [unbound][NameEntry::Unbound] entry to the name table.
    pub fn add_unbound(&mut self, name: Name, identifier: String) {
        self.add(name, NameEntry::Unbound(identifier));
    }

    /// Add a [bound][NameEntry::Bound] entry to the name table.
    pub fn add_bound(&mut self, name: Name, identifier: String, scope: usize) {
        self.add(name, NameEntry::Bound(identifier, scope));
    }

    /// Add a [synthetic][NameEntry::Synthetic] entry to the name table.
    pub fn add_synthetic(&mut self, name: Name) {
        self.add(name, NameEntry::Synthetic);
    }

    /// Get an entry from the name table. If the name does not have a mapping in the name table,
    /// it is assumed to be a [synthetic name][NameEntry::Synthetic].
    pub fn entry(&self, name: &Name) -> &NameEntry {
        return self.table.get(name).unwrap_or(&NameEntry::Synthetic);
    }

    /// Get an entry from the name table and format it as a string.
    pub fn write_entry(&self, name: &Name) -> String {
        return self.entry(name).write(name);
    }
}